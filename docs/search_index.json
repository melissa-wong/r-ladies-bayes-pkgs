[["rstanarm.html", "Chapter 3 rstanarm 3.1 Resources 3.2 Description 3.3 Environment Setup 3.4 Linear Model (Default Priors) 3.5 Linear Model (User-Defined Priors) 3.6 Semi-parametric Model 3.7 Session Info", " Chapter 3 rstanarm 3.1 Resources Regression and Other Stories by Gelman, Hill and Vehtari rstanarm online documentation 3.2 Description The rstanarm package is one of the easiest ways to get started with Bayesian models. The functions parallel the frequentist functions you’re probably already familiar with, and the syntax will also be familiar. You aren’t required to explicitly choose priors because all of the functions have weakly informative priors by default (although some might argue not being required to specify priors is a drawback). The primary limitation I’ve found thus far is the supported types for user-defined priors is somewhat limited. 3.3 Environment Setup rm(list=ls()) set.seed(123) options(&quot;scipen&quot; = 1, &quot;digits&quot; = 4) library(tidyverse) library(gridExtra) library(kableExtra) library(datasets) data(mtcars) library(rstanarm) library(bayesplot) # Set number of cores options(mc.cores = parallel::detectCores()-1) 3.4 Linear Model (Default Priors) 3.4.1 Define Model Let’s start with the following simple linear model: \\[\\begin{align*} mpg &amp;\\sim N(\\mu, \\sigma^2) \\\\ \\mu &amp;= a + b*disp \\\\ \\end{align*}\\] The stan_glm function from the rstanarm package fits a Bayesian linear model. The syntax is very similar to lm/glm. mdl1 &lt;- stan_glm(mpg ~ disp, data = mtcars) 3.4.2 Prior Predictive Distribution Next, I’ll examine the prior predictive distribution to see if the default priors seem reasonable. The prior_summary function shows the default priors for the model as well as the adjusted priors after automatic scaling. See http://mc-stan.org/rstanarm/articles/priors.html if you are interested in the details about how the default and adjusted priors are calculated. prior_summary(mdl1) ## Priors for model &#39;mdl1&#39; ## ------ ## Intercept (after predictors centered) ## Specified prior: ## ~ normal(location = 20, scale = 2.5) ## Adjusted prior: ## ~ normal(location = 20, scale = 15) ## ## Coefficients ## Specified prior: ## ~ normal(location = 0, scale = 2.5) ## Adjusted prior: ## ~ normal(location = 0, scale = 0.12) ## ## Auxiliary (sigma) ## Specified prior: ## ~ exponential(rate = 1) ## Adjusted prior: ## ~ exponential(rate = 0.17) ## ------ ## See help(&#39;prior_summary.stanreg&#39;) for more details Overlaying the default prior for the intercept with the EPA data gives a sense of what a weakly informative prior means for this data. # Plot prior predictive distribution using adjusted priors N &lt;- 100 prior_samples &lt;- data.frame(a = rnorm(N, 20, 15), b = rnorm(N, 0, 0.12)) D &lt;- seq(min(mtcars$disp), max(mtcars$disp), length.out = N) res &lt;- as.data.frame(apply(prior_samples, 1, function(x) x[1] + x[2] * (D-mean(mtcars$disp)))) %&gt;% mutate(disp = D) %&gt;% pivot_longer(cols=c(-&quot;disp&quot;), names_to=&quot;iter&quot;) res %&gt;% ggplot() + geom_line(aes(x=disp, y=value, group=iter), alpha=0.2) + labs(x=&quot;disp&quot;, y=&quot;prior predictive mpg&quot;) I notice two things in the prior predictive distribution which seem unrealistic given what I know about the real world: 1) negative mpg and 2) increasing mpg as displacement increases. Later on I’ll choose a more informative prior which incorporates this external knowledge. But let’s proceed with the analysis and see what happens. 3.4.3 Diagnostics I’ll walk through the steps for manually extracting the key diagnostic information from the mdl1 object since I think that can be helpful to understand exactly what’s going on. However, once you have a handle on these steps I highly recommend the shinystan package; it will automatically create all of these diagnostic plots (and more) with an nice interactive web interface. 3.4.3.1 Trace Plots The bayesplot package provides the function mcmc_trace which plots the Markov Chain Monte Carlo (MCMC) draws. mcmc_trace(mdl1, pars=c(&quot;disp&quot;, &quot;sigma&quot;)) There are three things I am looking for in the trace plot of each chain: Good mixing - In other words, the chain is rapidly changing values across the full region versus getting “stuck” near a particular value and slowly changing. Stationarity - The mean of the chain is relatively stable. Convergence - All of the chains spend most of the time around the same high-probability value. The trace plots above look good. 3.4.3.2 Trace Rank Plots It can sometimes be hard to interpret the trace plots when there are many chains. An alternative is the mcmc_rank_overlay function. This function plots a trace rank plot which is the distribution of the ranked samples; if the four chains have a roughly uniform distribution that indicates good mixing. mcmc_rank_overlay(mdl1, pars=c(&quot;disp&quot;, &quot;sigma&quot;)) 3.4.3.3 \\(\\widehat{R}\\) and Effective Sample Size In addition to visually examining the chains, we should also check \\(\\widehat{R}\\) which is a measure of convergence. \\(\\widehat{R} &gt; 1.0\\) indicates poor mixing, and the mc_stan documentation recommends only using samples if \\(\\widehat{R} &lt; 1.05\\). However, a recent paper by Vehtari et al. (2020) recommends \\(\\widehat{R} &lt; 1.01\\). Since MCMC samples are usually correlated, the effective sample size (n_eff) is often less than the number of samples. There is no hard and fast rule for what is an acceptable number for n_eff. McElreath’s guidance is it depends on what you are trying to estimate. If you are interested mostly in the posterior mean, then n_eff = 200 can be enough. But if you are interested in the tails of the distribution and it’s highly skewed then you’ll need n_eff to be much larger. There are two parameters, iter and warmup, which you can adjust in stan_glm if a larger n_eff is needed. The summary function displays n_eff and \\(\\widehat{R}\\) for the object returned by stan_glm. summary(mdl1) ## ## Model Info: ## function: stan_glm ## family: gaussian [identity] ## formula: mpg ~ disp ## algorithm: sampling ## sample: 4000 (posterior sample size) ## priors: see help(&#39;prior_summary&#39;) ## observations: 32 ## predictors: 2 ## ## Estimates: ## mean sd 10% 50% 90% ## (Intercept) 29.6 1.3 27.9 29.6 31.2 ## disp 0.0 0.0 0.0 0.0 0.0 ## sigma 3.4 0.5 2.8 3.3 4.0 ## ## Fit Diagnostics: ## mean sd 10% 50% 90% ## mean_PPD 20.1 0.9 19.0 20.1 21.2 ## ## The mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help(&#39;summary.stanreg&#39;)). ## ## MCMC diagnostics ## mcse Rhat n_eff ## (Intercept) 0.0 1.0 3501 ## disp 0.0 1.0 3328 ## sigma 0.0 1.0 3056 ## mean_PPD 0.0 1.0 3411 ## log-posterior 0.0 1.0 1529 ## ## For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1). 3.4.4 Posterior Distribution Since the chains, n_eff and \\(\\widehat{R}\\) look good, let’s examine the posterior distributions next. # Posterior point estimates (medians are used for point estimates) coef(mdl1) ## (Intercept) disp ## 29.57206 -0.04103 # 95% credible intervals knitr::kable(posterior_interval(mdl1, prob=0.95)) 2.5% 97.5% (Intercept) 27.0319 32.1255 disp -0.0509 -0.0313 sigma 2.6281 4.3876 3.4.5 Posterior Predictive Distribution The posterior_predict function draws samples from the posterior predictive distribution. The shinystan package also generates nice plots of the posterior predictive distribution. In this case, I’m going to plot the expected value of the posterior predictive distribution and overlay the observations since I think it can be easier to understand for someone new to these methods. The posterior_linpred function returns the linear predictor, possibly transformed by the inverse-link function. The posterior_epred function returns the expectation over the posterior predictive distribution. In this example, the model is a Gaussian likelihood with an identity link function, so the two functions return identical results. newdata &lt;- data.frame(disp=seq(min(mtcars$disp), max(mtcars$disp))) y_rep &lt;- as.data.frame(t(posterior_epred(mdl1, newdata=newdata, draws=50))) %&gt;% cbind(newdata) %&gt;% pivot_longer(cols=starts_with(&quot;V&quot;), names_to=&quot;grp&quot;, values_to=&quot;mpg&quot;) y_rep %&gt;% ggplot(aes(x=disp, y=mpg)) + geom_line(aes(group=grp), alpha=0.2) + geom_point(data = mtcars) 3.5 Linear Model (User-Defined Priors) Now I’ll specify priors which incorporate my prior knowledge that mpg is non-negative and is non-increasing as disp increases. My new model is as follows: \\[\\begin{align*} mpg &amp;\\sim N(\\mu, \\sigma^2) \\\\ \\mu &amp;= a + b*disp \\\\ a &amp;\\sim Normal(25,10^2) \\\\ b &amp;\\sim Normal(-0.2, 0.1^2) \\\\ \\sigma &amp;\\sim Exponential(1) \\end{align*}\\] The differences from the default priors are The intercept prior has a slightly smaller variance so negative values ofmpg are less likely. The slope prior is no longer symmetric about 0, but rather it is centered at -0.2 so that positive values are less likely. 3.5.1 Define Model mdl2 &lt;- stan_glm(mpg ~ disp, data = mtcars, prior = normal(-0.2, 0.1), # prior for slope prior_intercept = normal(25,10), # prior for intercept prior_aux = exponential(1)) # prior for standard deviation 3.5.2 Prior Predictive Distribution cdisp &lt;- mtcars$disp - mean(mtcars$disp) tmp &lt;- stan_glm(mpg ~ cdisp, data = mtcars, prior = normal(-0.2, 0.1), # prior for slope prior_intercept = normal(20,15), # prior for intercept prior_aux = exponential(1), # prior for standard deviation prior_PD = TRUE, chains=1) ## ## SAMPLING FOR MODEL &#39;continuous&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 7.5e-05 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.75 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 2000 [ 0%] (Warmup) ## Chain 1: Iteration: 200 / 2000 [ 10%] (Warmup) ## Chain 1: Iteration: 400 / 2000 [ 20%] (Warmup) ## Chain 1: Iteration: 600 / 2000 [ 30%] (Warmup) ## Chain 1: Iteration: 800 / 2000 [ 40%] (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%] (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%] (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%] (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%] (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%] (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%] (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 0.036544 seconds (Warm-up) ## Chain 1: 0.04268 seconds (Sampling) ## Chain 1: 0.079224 seconds (Total) ## Chain 1: prior_summary(tmp) ## Priors for model &#39;tmp&#39; ## ------ ## Intercept (after predictors centered) ## ~ normal(location = 20, scale = 15) ## ## Coefficients ## ~ normal(location = -0.2, scale = 0.1) ## ## Auxiliary (sigma) ## ~ exponential(rate = 1) ## ------ ## See help(&#39;prior_summary.stanreg&#39;) for more details draws &lt;- as.matrix(tmp) %&gt;% head(100) colMeans(draws) ## (Intercept) cdisp sigma ## 21.3987 -0.1943 0.9352 y &lt;- apply(draws, 1, function(x) x[1] + x[2] * (D - mean(mtcars$disp))) %&gt;% as_tibble() %&gt;% mutate(disp=D) %&gt;% pivot_longer(-disp, names_to=&quot;iter&quot;, values_to=&quot;mpg&quot;) ## Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. ## Using compatibility `.name_repair`. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. y %&gt;% ggplot() + geom_line(mapping=aes(x=disp, y=mpg, group=iter), alpha=0.2) # Plot prior predictive distribution using adjusted priors N &lt;- 100 prior_samples &lt;- data.frame(a = rnorm(N, 20, 15), b = rnorm(N, -0.2, 0.1)) D &lt;- seq(min(mtcars$disp), max(mtcars$disp), length.out = N) res &lt;- as.data.frame(apply(prior_samples, 1, function(x) x[1] + x[2] * (D-mean(mtcars$disp)))) %&gt;% mutate(disp = D) %&gt;% pivot_longer(cols=c(-&quot;disp&quot;), names_to=&quot;iter&quot;) res %&gt;% ggplot() + geom_line(aes(x=disp, y=value, group=iter), alpha=0.2) + labs(x=&quot;disp&quot;, y=&quot;prior predictive mpg&quot;) Compared to the prior predictive distribution with the default priors, this looks more consistent with my real-world knowledge that was reflected in the priors. 3.5.3 Diagnostics mcmc_trace(mdl2, pars=c(&quot;disp&quot;, &quot;sigma&quot;)) summary(mdl2) ## ## Model Info: ## function: stan_glm ## family: gaussian [identity] ## formula: mpg ~ disp ## algorithm: sampling ## sample: 4000 (posterior sample size) ## priors: see help(&#39;prior_summary&#39;) ## observations: 32 ## predictors: 2 ## ## Estimates: ## mean sd 10% 50% 90% ## (Intercept) 29.7 1.3 28.1 29.7 31.3 ## disp 0.0 0.0 0.0 0.0 0.0 ## sigma 3.2 0.4 2.7 3.2 3.7 ## ## Fit Diagnostics: ## mean sd 10% 50% 90% ## mean_PPD 20.1 0.8 19.1 20.1 21.2 ## ## The mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help(&#39;summary.stanreg&#39;)). ## ## MCMC diagnostics ## mcse Rhat n_eff ## (Intercept) 0.0 1.0 2856 ## disp 0.0 1.0 2791 ## sigma 0.0 1.0 2921 ## mean_PPD 0.0 1.0 3370 ## log-posterior 0.0 1.0 1656 ## ## For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1). The trace plots, n_eff and \\(\\widehat{R}\\) all look good. 3.5.4 Posterior Distribution Now let’s compare the posterior with informative versus default priors: # Point estimates knitr::kable(cbind(coef(mdl1), coef(mdl2)), col.names = c(&quot;Default&quot;, &quot;Informative&quot;)) Default Informative (Intercept) 29.572 29.6912 disp -0.041 -0.0415 # 95% credible intervals knitr::kable(cbind(posterior_interval(mdl1, prob=0.95), posterior_interval(mdl2, prob=0.95))) %&gt;% add_header_above(c(&quot; &quot; = 1, &quot;Default&quot; = 2, &quot;Informative&quot; = 2)) Default Informative 2.5% 97.5% 2.5% 97.5% (Intercept) 27.0319 32.1255 27.180 32.1083 disp -0.0509 -0.0313 -0.051 -0.0322 sigma 2.6281 4.3876 2.531 4.1268 In this case, there is sufficient data that the choice of prior really didn’t make much of a difference. 3.5.5 Posterior Predictive Distribution newdata &lt;- data.frame(disp=seq(min(mtcars$disp), max(mtcars$disp))) y_rep &lt;- as.data.frame(t(posterior_epred(mdl2, newdata=newdata, draws=50))) %&gt;% cbind(newdata) %&gt;% pivot_longer(cols=starts_with(&quot;V&quot;), names_to=&quot;grp&quot;, values_to=&quot;mpg&quot;) y_rep %&gt;% ggplot(aes(x=disp, y=mpg)) + geom_line(aes(group=grp), alpha=0.2) + geom_point(data = mtcars) 3.6 Semi-parametric Model 3.6.1 Define model The linear model is a poor choice for this data, so I’ll try a model with splines next. The stan_gamm4 function from the rstanarm package fits Bayesian nonlinear (and mixed) models. mdl3 &lt;- stan_gamm4(mpg ~ s(disp, bs=&quot;cr&quot;, k=7), data = mtcars, adapt_delta = 0.99) 3.6.2 Prior Predictive Distribution Unlike the linear model, it’s not as straightforward to manually construct the prior predictive distribution. Fortunately, rstanarm can automatically generate the prior predictive distribution too–we just refit the model without conditioning on the data by setting prior_PD = TRUE. mdl3_prior_pred &lt;- stan_gamm4(mpg ~ s(disp, bs=&quot;cr&quot;, k=7), data = mtcars, prior_PD = TRUE, adapt_delta = 0.99) N &lt;- 50 D &lt;- seq(min(mtcars$disp), max(mtcars$disp), length.out = N) prior_pred &lt;- data.frame(t(posterior_epred(mdl3_prior_pred, newdata=data.frame(disp=D), draws=N))) tmp &lt;- prior_pred %&gt;% mutate(disp = D)%&gt;% pivot_longer(cols=-&quot;disp&quot;, names_to=&quot;iter&quot;, values_to=&quot;mpg&quot;) tmp %&gt;% ggplot() + geom_line(mapping=aes(x=disp, y=mpg, group=iter), alpha=0.2) + geom_point(data=mtcars, mapping=aes(x=disp, y=mpg), color=&quot;blue&quot;) This prior predictive distribution gives us some crazy possibilities. However we saw earlier that there is enough data that the model isn’t very sensitive to the choice of prior, so let’s continue and see what happens. 3.6.3 Diagnostics and Posterior mcmc_trace(mdl3, regex_pars=c(&quot;disp&quot;, &quot;sigma&quot;)) summary(mdl3) ## ## Model Info: ## function: stan_gamm4 ## family: gaussian [identity] ## formula: mpg ~ s(disp, bs = &quot;cr&quot;, k = 7) ## algorithm: sampling ## sample: 4000 (posterior sample size) ## priors: see help(&#39;prior_summary&#39;) ## observations: 32 ## ## Estimates: ## mean sd 10% 50% 90% ## (Intercept) 20.1 0.4 19.5 20.1 20.6 ## s(disp).1 0.2 1.3 -1.2 0.2 1.6 ## s(disp).2 -0.9 1.1 -2.3 -0.8 0.3 ## s(disp).3 0.0 0.6 -0.7 0.0 0.7 ## s(disp).4 1.2 0.4 0.7 1.2 1.6 ## s(disp).5 0.4 0.1 0.2 0.4 0.6 ## s(disp).6 -3.1 0.3 -3.5 -3.1 -2.8 ## sigma 2.4 0.3 2.0 2.4 2.9 ## smooth_sd[s(disp)1] 1.2 0.7 0.5 1.0 2.1 ## smooth_sd[s(disp)2] 3.5 2.0 1.7 3.0 6.0 ## ## Fit Diagnostics: ## mean sd 10% 50% 90% ## mean_PPD 20.1 0.6 19.3 20.1 20.9 ## ## The mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help(&#39;summary.stanreg&#39;)). ## ## MCMC diagnostics ## mcse Rhat n_eff ## (Intercept) 0.0 1.0 3357 ## s(disp).1 0.0 1.0 3086 ## s(disp).2 0.0 1.0 2252 ## s(disp).3 0.0 1.0 4115 ## s(disp).4 0.0 1.0 2455 ## s(disp).5 0.0 1.0 4283 ## s(disp).6 0.0 1.0 3509 ## sigma 0.0 1.0 2720 ## smooth_sd[s(disp)1] 0.0 1.0 1229 ## smooth_sd[s(disp)2] 0.0 1.0 2250 ## mean_PPD 0.0 1.0 3322 ## log-posterior 0.1 1.0 842 ## ## For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1). The chains, n_eff and \\(\\widehat{R}\\) look good. In the Estimates section above, we also see the posteriors for the model parameters; there isn’t an intuitive interpretation of the spline coefficients so I’ll skip ahead to the posterior predictive distribution. 3.6.4 Posterior Predictive Distribution The expectation over the ppd is plotted below, along with a loess curve for comparison. This model is clearly a better fit to the data than the linear model. plot_nonlinear(mdl3, prob=0.95) + geom_point(mapping=aes(x=disp, y=mpg-mean(mpg)), data=mtcars) + labs(title=&quot;GAM&quot;, x=&quot;disp&quot;, y=&quot;mpg-mean(mpg)&quot;) ggplot(mapping=aes(x=disp, y=mpg-mean(mpg)), data=mtcars) + geom_point()+ stat_smooth(method=&quot;loess&quot;, level=0.95) + labs(title=&quot;LOESS&quot;) 3.7 Session Info sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices datasets utils methods base ## ## other attached packages: ## [1] bayesplot_1.7.2 rstanarm_2.21.1 Rcpp_1.0.5 kableExtra_1.3.1 ## [5] gridExtra_2.3 forcats_0.5.0 stringr_1.4.0 dplyr_1.0.2 ## [9] purrr_0.3.4 readr_1.4.0 tidyr_1.1.2 tibble_3.0.4 ## [13] ggplot2_3.3.2 tidyverse_1.3.0 ## ## loaded via a namespace (and not attached): ## [1] minqa_1.2.4 colorspace_2.0-0 ellipsis_0.3.1 ## [4] ggridges_0.5.2 rsconnect_0.8.16 markdown_1.1 ## [7] base64enc_0.1-3 fs_1.5.0 rstudioapi_0.13 ## [10] farver_2.0.3 rstan_2.21.2 DT_0.16 ## [13] fansi_0.4.1 lubridate_1.7.9.2 xml2_1.3.2 ## [16] splines_4.0.3 codetools_0.2-16 knitr_1.30 ## [19] shinythemes_1.1.2 jsonlite_1.7.1 nloptr_1.2.2.2 ## [22] broom_0.7.2 dbplyr_2.0.0 shiny_1.5.0 ## [25] compiler_4.0.3 httr_1.4.2 backports_1.2.0 ## [28] Matrix_1.2-18 assertthat_0.2.1 fastmap_1.0.1 ## [31] cli_2.2.0 later_1.1.0.1 htmltools_0.5.0 ## [34] prettyunits_1.1.1 tools_4.0.3 igraph_1.2.6 ## [37] gtable_0.3.0 glue_1.4.2 reshape2_1.4.4 ## [40] V8_3.4.0 cellranger_1.1.0 vctrs_0.3.5 ## [43] nlme_3.1-149 crosstalk_1.1.0.1 xfun_0.19 ## [46] ps_1.4.0 lme4_1.1-26 rvest_0.3.6 ## [49] mime_0.9 miniUI_0.1.1.1 lifecycle_0.2.0 ## [52] renv_0.12.0 gtools_3.8.2 statmod_1.4.35 ## [55] MASS_7.3-53 zoo_1.8-8 scales_1.1.1 ## [58] colourpicker_1.1.0 hms_0.5.3 promises_1.1.1 ## [61] parallel_4.0.3 inline_0.3.17 shinystan_2.5.0 ## [64] yaml_2.2.1 curl_4.3 loo_2.3.1 ## [67] StanHeaders_2.21.0-6 stringi_1.5.3 highr_0.8 ## [70] dygraphs_1.1.1.6 boot_1.3-25 pkgbuild_1.1.0 ## [73] rlang_0.4.9 pkgconfig_2.0.3 matrixStats_0.57.0 ## [76] evaluate_0.14 lattice_0.20-41 labeling_0.4.2 ## [79] rstantools_2.1.1 htmlwidgets_1.5.2 tidyselect_1.1.0 ## [82] processx_3.4.5 plyr_1.8.6 magrittr_2.0.1 ## [85] bookdown_0.21 R6_2.5.0 generics_0.1.0 ## [88] DBI_1.1.0 mgcv_1.8-33 pillar_1.4.7 ## [91] haven_2.3.1 withr_2.3.0 xts_0.12.1 ## [94] survival_3.2-7 modelr_0.1.8 crayon_1.3.4 ## [97] rmarkdown_2.5 grid_4.0.3 readxl_1.3.1 ## [100] callr_3.5.1 threejs_0.3.3 reprex_0.3.0 ## [103] digest_0.6.27 webshot_0.5.2 xtable_1.8-4 ## [106] httpuv_1.5.4 RcppParallel_5.0.2 stats4_4.0.3 ## [109] munsell_0.5.0 viridisLite_0.3.0 shinyjs_2.0.0 References "]]
