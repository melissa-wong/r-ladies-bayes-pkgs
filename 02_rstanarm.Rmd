# rstanarm {#rstanarm}

## Resources

- [Regression and Other Stories](https://avehtari.github.io/ROS-Examples/index.html) by Gelman, Hill and Vehtari

- [rstanarm online documentation](https://mc-stan.org/users/interfaces/rstanarm)

## Description

The `rstanarm` package is one of the easiest ways to get started with Bayesian models. The functions parallel the frequentist functions you're probably already familiar with, and the syntax will also be familiar. You aren't required to explicitly choose priors because all of the functions have weakly informative priors by default (although some might argue _not_ being required to specify priors is a drawback). The primary limitation I've found thus far is the supported types for user-defined priors is somewhat limited.

## Environment Setup
```{r setup, results="hide", message=FALSE}
rm(list=ls())

set.seed(123)
options("scipen" = 1, "digits" = 4)

library(tidyverse)
library(gridExtra)
library(kableExtra)
library(datasets)
data(mtcars)

library(rstanarm)
library(bayesplot)
```

## Linear Model (Default Priors)

### Define Model

Let's start with the following simple linear model:

\begin{align*}
  mpg &\sim N(\mu, \sigma^2) \\
  \mu &= a + b*disp \\
\end{align*}

The `stan_glm` function from the `rstanarm` package fits a Bayesian linear model.  The syntax is very similar to `lm`/`glm`.

```{r mdl1, results='hide'}
mdl1 <- stan_glm(mpg ~ disp, data = mtcars)
```
### Prior Predictive Distribution

Next, I'll examine the prior predictive distribution to see if the default priors seem reasonable.  The `prior_summary` function shows the default priors for the model as well as the adjusted priors after automatic scaling.  See http://mc-stan.org/rstanarm/articles/priors.html if you are interested in the details about how the default and adjusted priors are calculated. 

```{r mdl1_prior}
prior_summary(mdl1)
```

```{r mdl1_prior_plot}
# Plot prior predictive distribution using adjusted priors
N <- 100

prior_samples <- data.frame(a = rnorm(N, 20, 15),
                            b = rnorm(N, 0, 0.12))

D <- seq(min(mtcars$disp), max(mtcars$disp), length.out = N)

res <- as.data.frame(apply(prior_samples, 1, 
                           function(x) x[1] + x[2] * (D-mean(mtcars$disp)))) %>%
  mutate(disp = D) %>%
  pivot_longer(cols=c(-"disp"), names_to="iter") 

res %>%
  ggplot() +
  geom_line(aes(x=disp, y=value, group=iter), alpha=0.2) +
  labs(x="disp", y="prior predictive mpg")
```

I notice two things in the prior predictive distribution which seem unrealistic given what I know about the real world: 1) negative mpg and 2) increasing mpg as displacement increases. Later on I'll choose a more informative prior which incorporates this external knowledge. But let's proceed with the analysis and see what happens.

### Diagnostics

I'll walk through the steps for manually extracting the key diagnostic information from the `mdl1` object since I think that can be helpful to understand exactly what's going on.  However, once you have a handle on these steps I highly recommend the `shinystan` package; it will automatically create all of these diagnostic plots (and more) with an nice interactive web interface.

#### Trace Plots

The `bayesplot` package provides the function `mcmc_trace` which plots the Markov Chain Monte Carlo (MCMC) draws.

```{r mdl1_trace}
mcmc_trace(mdl1, pars=c("disp", "sigma"))
```

There are three things I am looking for in the trace plot of each chain:

  1. *Good mixing* -  In other words, the chain is rapidly changing values across the full region versus getting "stuck" near a particular value and slowly changing.
  
  2. *Stationarity* - The mean of the chain is relatively stable.
  
  3. *Convergence* - All of the chains spend most of the time around the same high-probability value.
    
The trace plots above look good. 

#### Trace Rank Plots

It can sometimes be hard to interpret the trace plots when there are many chains. An alternative is the `mcmc_rank_overlay` function.  This function plots a trace rank plot which is the distribution of the ranked samples; if the four chains have a roughly uniform distribution that indicates good mixing.

```{r mdl1_trank_plot}
mcmc_rank_overlay(mdl1, pars=c("disp", "sigma"))
```

#### $\widehat{R}$ and Effective Sample Size

In addition to visually examining the chains, we should also check $\widehat{R}$ which is a measure of convergence.  $\widehat{R} > 1.0$ indicates poor mixing, and the `mc_stan` documentation recommends only using samples if $\widehat{R} < 1.05$.  However, a recent paper by @Vehtari_2020 recommends $\widehat{R} < 1.01$.

Since MCMC samples are usually correlated, the effective sample size (`n_eff`) is often less than the number of samples. There is no hard and fast rule for what is an acceptable number for `n_eff`. McElreath’s guidance is it depends on what you are trying to estimate. If you are interested mostly in the posterior mean, then `n_eff` = 200 can be enough. But if you are interested in the tails of the distribution and it’s highly skewed then you’ll need `n_eff` to be much larger. There are two parameters, `iter` and `warmup`, which you can adjust in `stan_glm` if a larger `n_eff` is needed.

The `summary` function displays `n_eff` and $\widehat{R}$ for the object returned by `stan_glm`.

```{r mdl1_summary}
summary(mdl1)
```

### Posterior Distribution

Since the chains, `n_eff` and $\widehat{R}$ look good, let's examine the posterior distributions next.

```{r mdl1_post}
# Posterior point estimates (medians are used for point estimates)
coef(mdl1)
```

```{r mdl1_post_int}
# 95% credible intervals
knitr::kable(posterior_interval(mdl1, prob=0.95))
```


### Posterior Predictive Distribution

The `posterior_predict` function draws samples from the posterior predictive distribution. The `shinystan` package also generates nice plots of the posterior predictive distribution.

In this case, I'm going to plot the expected value of the posterior predictive distribution and overlay the observations since I think it can be easier to understand for someone new to these methods. The `posterior_linpred` function returns the linear predictor, possibly transformed by the inverse-link function.  The `posterior_epred` function returns the expectation over the posterior predictive distribution. In this example, the model is a Gaussian likelihood with an identity link function, so the two functions return identical results.

```{r mdl1_ppd}
newdata <- data.frame(disp=seq(min(mtcars$disp), max(mtcars$disp)))

y_rep <- as.data.frame(t(posterior_epred(mdl1, newdata=newdata, draws=50))) %>%
  cbind(newdata) %>%
  pivot_longer(cols=starts_with("V"), names_to="grp", values_to="mpg")

y_rep %>%
  ggplot(aes(x=disp, y=mpg)) +
  geom_line(aes(group=grp), alpha=0.2) +
  geom_point(data = mtcars) 
```


## Linear Model (User-Defined Priors)

Now I'll specify priors which incorporate my prior knowledge that `mpg` is non-negative and is non-increasing as `disp` increases.  My new model is as follows:

\begin{align*}
  mpg &\sim N(\mu, \sigma^2) \\
  \mu &= a + b*disp \\
  a &\sim Normal(25,10^2) \\
  b &\sim Normal(-0.2, 0.1^2) \\
  \sigma &\sim Exponential(1)
\end{align*}

The differences from the default priors are

1. The intercept prior has a slightly smaller variance so negative values of`mpg` are less likely.

2. The slope prior is no longer symmetric about 0, but rather it is centered at -0.2 so that positive values are less likely.

### Define Model

```{r mdl2, results="hide"}
mdl2 <- stan_glm(mpg ~ disp, data = mtcars,
                 prior = normal(-0.2, 0.1), # prior for slope
                 prior_intercept = normal(25,10), # prior for intercept
                 prior_aux = exponential(1))  # prior for standard deviation
```

### Prior Predictive Distribution

```{r mdl2_prior_plot}
# Plot prior predictive distribution using adjusted priors
N <- 100

prior_samples <- data.frame(a = rnorm(N, 25, 10),
                            b = rnorm(N, -0.2, 0.1))

D <- seq(min(mtcars$disp), max(mtcars$disp), length.out = N)

res <- as.data.frame(apply(prior_samples, 1, 
                           function(x) x[1] + x[2] * (D-mean(mtcars$disp)))) %>%
  mutate(disp = D) %>%
  pivot_longer(cols=c(-"disp"), names_to="iter") 

res %>%
  ggplot() +
  geom_line(aes(x=disp, y=value, group=iter), alpha=0.2) +
  labs(x="disp", y="prior predictive mpg")
```

Compared to the prior predictive distribution with the default priors, this looks more consistent with my real-world knowledge that was reflected in the priors.

### Diagnostics

```{r mdl2_trace}
mcmc_trace(mdl2, pars=c("disp", "sigma"))
```

```{r}
summary(mdl2)
```
The trace plots, `n_eff` and $\widehat{R}$ all look good.

### Posterior Distribution

Now let's compare the posterior with informative versus default priors:

```{r mdl2_post}
# Point estimates
knitr::kable(cbind(coef(mdl1), coef(mdl2)), col.names = c("Default", "Informative"))
```

```{r mdl2_post_int, message=FALSE}
# 95% credible intervals
knitr::kable(cbind(posterior_interval(mdl1, prob=0.95),
                  posterior_interval(mdl2, prob=0.95))) %>%
  add_header_above(c(" " = 1, "Default" = 2, "Informative" = 2))
```

In this case, there is sufficient data that the choice of prior really didn't make much of a difference.

### Posterior Predictive Distribution

```{r mdl2_ppd}
newdata <- data.frame(disp=seq(min(mtcars$disp), max(mtcars$disp)))

y_rep <- as.data.frame(t(posterior_epred(mdl2, newdata=newdata, draws=50))) %>%
  cbind(newdata) %>%
  pivot_longer(cols=starts_with("V"), names_to="grp", values_to="mpg")

y_rep %>%
  ggplot(aes(x=disp, y=mpg)) +
  geom_line(aes(group=grp), alpha=0.2) +
  geom_point(data = mtcars) 
```

## Semi-parametric Model

### Define model

The linear model is a poor choice for this data, so I'll try a model with splines next. The `stan_gamm4` function from the `rstanarm` package fits Bayesian nonlinear (and mixed) models.

```{r mdl3, results='hide'}
mdl3 <- stan_gamm4(mpg ~ s(disp, bs="cr", k=7), 
                   data = mtcars, 
                   adapt_delta = 0.99)
```

### Prior Predictive Distribution

Unlike the linear model, it's not as straightforward to manually construct the prior predictive distribution.  Fortunately, `rstanarm` can automatically generate the prior predictive distribution too--we just refit the model _without_ conditioning on the data by setting `prior_PD = TRUE`.

```{r mdl3_prior, results="hide"}
mdl3_prior_pred <- stan_gamm4(mpg ~ s(disp, bs="cr", k=7), 
                   data = mtcars, 
                   prior_PD = TRUE,
                   adapt_delta = 0.99)
```

```{r}
N <- 50

D <- seq(min(mtcars$disp), max(mtcars$disp), length.out = N)

prior_pred <- data.frame(t(posterior_epred(mdl3_prior_pred,
                                newdata=data.frame(disp=D),
                                draws=N)))

tmp <- prior_pred %>%
  mutate(disp = D)%>%
  pivot_longer(cols=-"disp", names_to="iter", values_to="mpg") 

tmp %>%
  ggplot() +
  geom_line(mapping=aes(x=disp, y=mpg, group=iter), alpha=0.2) +
  geom_point(data=mtcars, mapping=aes(x=disp, y=mpg), color="blue")
```

This prior predictive distribution gives us some crazy possibilities. However we saw earlier that there is enough data that the model isn't very sensitive to the choice of prior, so let's continue and see what happens.

### Diagnostics and Posterior

```{r}
mcmc_trace(mdl3, regex_pars=c("disp", "sigma"))
```

```{r}
summary(mdl3)
```

The chains, `n_eff` and $\widehat{R}$ look good. In the Estimates section above, we also see the posteriors for the model parameters; there isn't an intuitive interpretation of the spline coefficients so I'll skip ahead to the posterior predictive distribution.

### Posterior Predictive Distribution

The expectation over the ppd is plotted below, along with a loess curve for comparison. This model is clearly a better fit to the data than the linear model.

```{r mdl3_ppd, figures-side, fig.show="hold", out.width="50%", message=FALSE}

plot_nonlinear(mdl3, prob=0.95) +
  geom_point(mapping=aes(x=disp, y=mpg-mean(mpg)),
             data=mtcars) +
  labs(title="GAM", x="disp", y="mpg-mean(mpg)")

ggplot(mapping=aes(x=disp, y=mpg-mean(mpg)),
              data=mtcars) +
  geom_point()+
  stat_smooth(method="loess",
              level=0.95) +
  labs(title="LOESS")

```

## Session Info

```{r}
sessionInfo()
```
